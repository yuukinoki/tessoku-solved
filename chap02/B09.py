N = int(input())

#紙の情報入力
A = [0]*(N+1)
B = [0]*(N+1)
C = [0]*(N+1)
D = [0]*(N+1)
for i in range(1,N+1):
    A[i],B[i],C[i],D[i] = map(int,input().split())



#二次元平面を作成
S = [[0]*1503 for _ in range(1503)] #これは、計算を容易にするために初めの行、列を初期化する必要があるため、余分に作る必要がある。
                                    #さらに、配列の範囲外アクセスを避けるためにもう一つ確保する。要するに全部で、初期化用1つ、エラー避け1つ増やした。

#座標のインプット
#Sの範囲は0 ~ 1502で　1~1501を実際の0~1500としてつかって、初めの0は初期化用として使う。つまり受け取る座標すべては+1しなければならない。
for i in range(1,N+1):
    S[A[i]+1][B[i]+1] += 1 #左下
    S[A[i]+1][D[i]+1] -= 1 #左上
    S[C[i]+1][B[i]+1] -= 1 #右下
    S[C[i]+1][D[i]+1] += 1 #右上


#紙のある場所を累積和を格納して求める行列を作成
Answer = [[0]*1503 for _ in range(1503)]
sum = 0 #面積を格納する変数
#横方向の累積和を計算
for y in range(1,1502): #0~1500を表している
    for x in range(1,1502):
        Answer[x][y] += S[x][y] + Answer[x-1][y] #今指してる値と、ひとつ前のまでの累積和を足していく
#縦方向の累積和を計算
for x in range(1,1502):
    for y in range(1,1502):
        Answer[x][y] += Answer[x][y-1]
        if Answer[x][y] > 0:
            sum += 1
print(sum)

#くそ詰まったポイント
#S,Answerの配列が持つ意味と問題が求める答えをちゃんと理解していないと痛い目を見る。
# Sは紙の切れ端の位置、
# Answerはそれらを累積和で計算することで紙のある位置を洗い出せる。
# 求められている答えは紙の面積なのでsumで紙のあるマス数をカウント


#初めの座標インプットが違っていた。→　なぜ？
# 座標系とマス目の扱いを一緒にしてしまってはいけない。
#座標はあくまで境界を指す。
# マス目には紙が存在するかどうかを格納したいため、
# マス目の[i][j]は(i+0.5,j+0.5)と考える
#例えば
#(A,B)が(1,1)であった場合、マス目[1][1]には紙があるために+1をする
#(C,D)が(3,3)であった場合、マス目[3][3]（座標では(3+0.5,3+0.5)）には紙がないため-1をする

#マス目と座標は一緒にするな!!!!!
#以上!!!